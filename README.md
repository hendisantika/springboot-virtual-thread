# Spring Boot Virtual Thread Demo

## Overview

This project demonstrates the use of Java's Virtual Threads (Project Loom) in a Spring Boot application, comparing
different threading models for performance and resource usage.

### Key Features

1. **Report Generation API**: Provides endpoints for generating customer reports using three different threading models:
   - **Simple Threading**: Uses the default Tomcat thread pool (synchronous execution)
   - **Platform Threading**: Uses a fixed thread pool with traditional platform threads (asynchronous execution)
   - **Virtual Threading**: Uses Java's Virtual Threads (Project Loom) for lightweight concurrency (asynchronous
     execution)

2. **User Management API**: Provides a RESTful API for managing user data, automatically exposed via Spring Data REST:
   - CRUD operations for User entities
   - Custom search endpoints for finding users by name, email, and age

3. **Performance Testing**: Includes Gatling simulations for load testing the User API endpoints

The application allows you to compare the performance and resource usage of these different threading models under
various load conditions.

## Prerequisites

- Java 21+ (for Virtual Thread support)
- Gradle
- Docker (optional, for running with Docker Compose)

## Getting Started

### Clone the repository

```bash
git clone https://github.com/hendisantika/springboot-virtual-thread.git
cd springboot-virtual-thread
```

### Build the application

```bash
./gradlew build
```

### Run the application

```bash
./gradlew bootRun
```

Or using Docker Compose:

```bash
docker-compose up
```

## API Endpoints

### Report Endpoints

The application provides three endpoints for generating reports:

1. **Simple Threading (Synchronous)**:
   ```
   POST /reports/{region}
   ```

2. **Platform Threading (Asynchronous with fixed thread pool)**:
   ```
   POST /reports/platform/{region}
   ```

3. **Virtual Threading (Asynchronous with virtual threads)**:
   ```
   POST /reports/virtual/{region}
   ```

Where `{region}` is a parameter specifying the region for which to generate the report (e.g., "US", "EU", etc.).

### User Endpoints (Spring Data REST)

The application also includes a User entity exposed via Spring Data REST:

1. **Get All Users**:
   ```
   GET /users
   ```

2. **Get User by ID**:
   ```
   GET /users/{id}
   ```

3. **Create User**:
   ```
   POST /users
   ```
   Example request body:
   ```json
   {
     "name": "John Doe",
     "email": "johndoe@gmail.com",
     "age": 30
   }
   ```

4. **Update User**:
   ```
   PUT /users/{id}
   ```

5. **Delete User**:
   ```
   DELETE /users/{id}
   ```

6. **Search Users**:
   ```
   GET /users/search/findByName?name={name}
   GET /users/search/findByEmail?email={email}
   GET /users/search/findByAge?age={age}
   ```

These endpoints are automatically generated by Spring Data REST based on the `UserRepository` interface.

## API Documentation

The application includes Swagger UI for interactive API documentation and testing. Once the application is running, you
can access the API documentation at:

```
http://localhost:8080/swagger-ui
```

This interface provides:

- Detailed information about all available endpoints
- The ability to try out API calls directly from the browser
- Request and response schemas
- Available parameters and their descriptions

The raw OpenAPI specification is also available at:

```
http://localhost:8080/v3/api-docs
```

## Performance Testing

### Apache Benchmark (ab) Testing

You can use Apache Benchmark to test the performance of the different endpoints:

#### Testing Simple Threading

```bash
ab -n 1000 -c 100 -m POST http://localhost:8080/reports/US
```

#### Testing Platform Threading

```bash
ab -n 1000 -c 100 -m POST http://localhost:8080/reports/platform/US
```

#### Testing Virtual Threading

```bash
ab -n 1000 -c 100 -m POST http://localhost:8080/reports/virtual/US
```

Parameters:

- `-n 1000`: Send 1000 requests
- `-c 100`: Concurrency level of 100 requests at a time
- `-m POST`: Use POST method

### Gatling Testing

The project includes [Gatling](https://gatling.io/) simulations for performance testing. Gatling is a powerful
open-source load testing tool that provides detailed reports and metrics.

#### Available Simulations

1. **GetAllUsersSimulation**: Tests the GET `/users` endpoint with:
   - 10 users at once
   - Ramping up to 10 users during 10 seconds
   - Assertions for response time (< 1500ms), success rate (> 95%), and failed requests (< 5)

2. **PostUsersSimulation**: Tests the POST `/users` endpoint with:
   - 10 users at once
   - Ramping up to 10 users during 10 seconds
   - JSON payload with name, email, and age
   - Assertions for response time (< 1500ms), success rate (> 95%), and failed requests (< 5)

3. **ReportControllerSimulation**: Tests all three report generation endpoints with:
   - Ramping up to 50 users over 30 seconds for each endpoint
   - Assertions for response time (< 3000ms), success rate (> 95%), and failed requests (< 10)
   - Compares performance between standard, platform, and virtual thread implementations

#### Running Gatling Simulations

To run the Gatling simulations, use the Gradle task:

```bash
./gradlew gatlingRun
```

This will execute all simulations and generate detailed HTML reports in the `build/reports/gatling` directory.

#### Detailed Gatling Documentation

For more detailed information about the Gatling tests for the ReportController, see:

- [GATLING.md](GATLING.md) - Detailed instructions on running and analyzing the Gatling tests
- [GATLING_REPORT_SAMPLE.md](GATLING_REPORT_SAMPLE.md) - Sample Gatling report structure and interpretation

### k6 Testing

[k6](https://k6.io/) is a modern load testing tool. Create a file named `load-test.js` with the following content:

```javascript
import http from 'k6/http';
import {sleep} from 'k6';

export const options = {
   vus: 100,  // Number of virtual users
   duration: '30s',  // Test duration
};

export default function () {
   // Test simple threading
   http.post('http://localhost:8080/reports/US');

   // Test platform threading
   http.post('http://localhost:8080/reports/platform/US');

   // Test virtual threading
   http.post('http://localhost:8080/reports/virtual/US');

   sleep(1);
}
```

Run the test:

```bash
k6 run load-test.js
```

For more targeted testing, you can create separate scripts for each endpoint:

**simple-test.js**:

```javascript
import http from 'k6/http';
import {sleep} from 'k6';

export const options = {
   vus: 100,
   duration: '30s',
};

export default function () {
   http.post('http://localhost:8080/reports/US');
   sleep(1);
}
```

**platform-test.js**:

```javascript
import http from 'k6/http';
import {sleep} from 'k6';

export const options = {
   vus: 100,
   duration: '30s',
};

export default function () {
   http.post('http://localhost:8080/reports/platform/US');
   sleep(1);
}
```

**virtual-test.js**:

```javascript
import http from 'k6/http';
import {sleep} from 'k6';

export const options = {
   vus: 100,
   duration: '30s',
};

export default function () {
   http.post('http://localhost:8080/reports/virtual/US');
   sleep(1);
}
```

Run individual tests:

```bash
k6 run simple-test.js
k6 run platform-test.js
k6 run virtual-test.js
```

## Understanding the Threading Models

### Simple Threading

The simple threading model uses the default Tomcat thread pool (typically 200 threads) to handle requests synchronously.
Each request is processed in the current thread, and if all threads are busy, new requests are queued (up to 100
requests by default).

### Platform Threading

The platform threading model uses a fixed thread pool (5 threads in this implementation) to handle requests
asynchronously. This allows the Tomcat threads to be released quickly, but the actual work is still done by platform
threads, which are relatively heavyweight.

### Virtual Threading

The virtual threading model uses Java's Virtual Threads (Project Loom) to handle requests asynchronously. Virtual
threads are lightweight and managed by the JVM, allowing for much higher concurrency without the overhead of platform
threads.

## Expected Results

When testing under high load:

1. **Simple Threading**: May become unresponsive as Tomcat threads are exhausted
2. **Platform Threading**: Better than simple threading but still limited by the number of platform threads
3. **Virtual Threading**: Should handle much higher concurrency with lower resource usage

## License

This project is licensed under the MIT License - see the LICENSE file for details.